# 🎰 로또 게임

**로또 게임**은 사용자에게 로또 번호를 발행하고, 사용자가 입력한 로또 번호와 당첨 번호를 비교하여 당첨 내역과 수익률을 계산하는 프로젝트입니다. <br/>
이 프로젝트는 로또 게임을 시뮬레이션하고, 사용자에게 로또를 구매할 기회를 제공하며, 당첨 번호와 비교하여 당첨 결과 및 수익률을 확인할 수 있는 기능을 포함하고 있습니다.

## 💡 구현할 기능 목록

1. **게임 시작을 알리는 문구 출력**
    - "로또 게임을 시작합니다."
2. **로또 구입**
    - "구입금액을 입력해 주세요. (1,000원 단위로 입력)" 출력
    - 1,000원으로 나누어 떨어지지 않는 경우 예외 처리
    - 사용자로부터 구입 금액 입력받기
3. **로또 번호 발행**
    - 구매한 로또 수량에 맞게 로또 번호 생성
4. **로또 번호 출력**
    - 발행된 로또 번호를 출력
    - 로또 번호는 오름차순으로 정렬
5. **당첨 번호 및 보너스 번호 입력**
    - "당첨 번호를 입력하세요. (1~45까지 중복되지 않는 6개의 번호, 쉼표(,)로 구분)" 출력
    - 사용자로부터 당첨 번호 6개 입력받기
    - "보너스 번호를 입력하세요. (1~45까지 중복되지 않는 번호)" 출력
    - 보너스 번호 입력받기
6. **당첨 통계 확인**
    - 사용자가 구매한 로또 번호와 당첨 번호를 비교하여 당첨 내역 및 수익률 출력
    - 수익률은 소수점 둘째 자리에서 반올림 (ex. 100.0%, 51.5%, 1,000,000.0%)
7. **예외 처리**
    - 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException를 발생시켜 "[ERROR]"로 시작하는 에러 메시지 출력
    - 출력 후 그 부분부터 재입력 받기
8. **indent(들여쓰기) depth 관리**
    - 함수(또는 메서드)가 3 이상의 들여쓰기 depth를 가지지 않도록 구현
9. **함수(또는 메서드) 분리**
    - 함수(또는 메서드)가 한 가지 일만 하도록 작게 만들어 코드 가독성을 높임
10. **테스트 코드 작성**
    - JUnit 5와 AssertJ를 사용하여 구현한 기능이 정상 동작하는지 확인하는 테스트 코드 작성

## ⚙️ Architecture/Design Pattern

### MVVM

**View와 Model 사이의 의존성을 낮춰주는 패턴으로 온보딩, 확장성, 유지보수성, 테스트 용이성 등 다양한 이점이 있는 MVVM 패턴 채택**

<br/>

## 📑 File Structure

##### dataLayer

- Model

- repository

##### uiLayer

- model
- repository
- viewmodel

##### utils

## 🤔 테스트를 작성하는 이유

<br/>

## 📌 Convention

### Commit Message Convention

| Tag          | Description                   |
|--------------|-------------------------------|
| [Feat] :     | 새로운 기능을 추가                    |
| [Fix] :      | 버그 수정                         |
| [Docs] :     | 문서 수정, 필요한 주석 추가 및 변경         |
| [Test] :     | 테스트 코드, 리팩토링 테스트 코드 추가        |
| [Refactor] : | 코드 구조 변경 등 리팩토링               |
| [Rename] :   | 파일 또는 폴더 명을 수정하거나 옮기는 작업만인 경우 |
| [Remove] :   | 파일을 삭제하는 작업만 수행한 경우           |
| [Const] :    | 상수 추가 또는 변경                   |

- 제목과 본문을 빈행으로 분리
- 여러가지 항목이 있다면 글머리 기호를 통해 가독성 높이기
- 자신의 코드가 직관적으로 바로 파악할 수 있다고 생각하지 않기

### Coding Convention

**❝**  **문자열을 처리할 때는 쌍따옴표를 사용하도록 합니다.**

🐫 **함수명, 변수명은 카멜케이스로 작성합니다. (camelCase)**

🤙 **변수 이름에 자료형은 사용하지 않습니다.**

- 변수 이름에 자료형, 자료 구조 등을 사용하지 않는다.

☝ **한 함수가 한 가지 기능만 담당하게 합니다.**

- 함수 길이가 길어진다면 한 함수에서 여러 일을 하려고 하는 경우일 가능성이 높다.
- 아래와 같이 한 함수에서 안내 문구 출력, 사용자 입력, 유효값 검증 등 여러 일을 하고 있다면 이를 적절하게 분리한다.

```kotlin
fun userInput(): List<String> {
    println("경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분)")
    val userInput = Console.readLine().trim()
    val splittedName = userInput.split(",")
    splittedName.forEach {
        require(user.length <= 5) { "[ERROR] 자동차 이름은 1자 이상 5자 이하만 가능합니다." }
    }
    return splittedName
}
```

☝ **가독성을 위해 한 줄에 하나의 문장만 작성합니다.**

🤙 **코드 구현 완료 후 정렬을 해줍니다. (`ctrl` + `Alt` + `L`), (`command` + `option` + `L`)**

🐈 **의미 없는 주석을 달지 않습니다.**

- 변수 이름, 함수(메서드) 이름을 통해 어떤 의도인지가 드러난다면 굳이 주석을 달지 않는다.
- 모든 변수와 함수에 주석을 달기보다 가능하면 이름을 통해 의도를 드러내고, 의도를 드러내기 힘든 경우 주석을 다는 연습을 한다.

☝ **값을 하드 코딩하지 않습니다.**

- 문자열, 숫자 등의 값을 하드 코딩하지 않는다.
- 상수를 만들고 이름을 부여해 이 변수의 역할이 무엇인지 의도를 드러낸다.
- 구글에서 "kotlin 상수"와 같은 키워드로 검색해 상수 구현 방법을 학습하고 적용해 본다.

☝ **구현 순서를 지킵니다.**

- 클래스는 프로퍼티, init 블록, 부 생성자, 메서드, 동반 객체 순으로 작성한다.

```kotlin
class A {
    프로퍼티

    init 블록

    부 생성자

    메서드

    동반 객체
}
```

☝ **연산자 사이에는 공백을 추가하여 가독성을 높입니다.**

```kotlin
a + b + c + d // bad
a + b + c + d // good
```

☝ **콤마 다음에 값이 올 경우 공백을 추가하여 가독성을 높입니다.**

```kotlin
var arr = [1, 2, 3, 4] //bad
var arr = [1, 2, 3, 4] //good
```


